//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
)

const codegenHeader = `// Code generated by go run zgen.go. DO NOT EDIT.`

var pkg string

func main() {
	flag.StringVar(&pkg, "p", "", "package name")
	flag.Parse()
	if pkg == "" {
		log.Fatal("package name (-p flag) must not be empty")
	}
	if xs := mustLoadOrNil("ztrampolines.txt"); xs != nil {
		genGoTrampolines(xs)
		genAsmTrampolines(xs)
	}
	if xs := mustLoadOrNil("zglobals.txt"); xs != nil {
		genGoGlobals(xs)
	}
	if xs := mustLoadOrNil("ztypes.txt"); xs != nil {
		genGoTypes(xs)
	}
}

func genGoTrampolines(trampolines []Mapping) {
	g := bytes.NewBuffer(nil)
	fmt.Fprintln(g, codegenHeader)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `//go:build darwin`)
	fmt.Fprintln(g, `// +build darwin`)
	fmt.Fprintln(g)
	fmt.Fprintf(g, `package %s`+"\n", pkg)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `import (`)
	fmt.Fprintln(g, "\t"+`"unsafe"`)
	fmt.Fprintln(g, `)`)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `const sizeofUintptr = unsafe.Sizeof(uintptr(0))`)
	for _, m := range trampolines {
		lib := m.From
		for _, fn := range m.To {
			fmt.Fprintln(g)
			fmt.Fprintf(g, `var extern_%s_trampolineABI0 uintptr`+"\n", fn)
			fmt.Fprintln(g)
			fmt.Fprintf(g, `//go:cgo_import_dynamic extern_%[1]s %[1]s "%[2]s"`+"\n", fn, lib)
			fmt.Fprintf(g, `func extern_%s_trampoline()`+"\n", fn)
		}
	}
	if err := os.WriteFile("ztrampolines.go", g.Bytes(), 0o644); err != nil {
		log.Fatal(err)
	}
}

func genAsmTrampolines(trampolines []Mapping) {
	g := bytes.NewBuffer(nil)
	fmt.Fprintln(g, codegenHeader)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `//go:build darwin`)
	fmt.Fprintln(g, `// +build darwin`)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `#include "go_asm.h"`)
	fmt.Fprintln(g, `#include "textflag.h"`)
	for _, m := range trampolines {
		for _, fn := range m.To {
			fmt.Fprintln(g)
			fmt.Fprintf(g, `GLOBL 路extern_%s_trampolineABI0(SB),NOPTR|RODATA,$const_sizeofUintptr`+"\n", fn)
			fmt.Fprintf(g, `DATA 路extern_%[1]s_trampolineABI0(SB)/const_sizeofUintptr,$路extern_%[1]s_trampoline(SB)`+"\n", fn)
			fmt.Fprintf(g, `TEXT 路extern_%s_trampoline(SB),NOSPLIT,$0-0`+"\n", fn)
			fmt.Fprintf(g, "\t"+`JMP extern_%s(SB)`+"\n", fn)
		}
	}
	if err := os.WriteFile("ztrampolines.s", g.Bytes(), 0o644); err != nil {
		log.Fatal(err)
	}
}

func genGoGlobals(globals []Mapping) {
	g := bytes.NewBuffer(nil)
	fmt.Fprintln(g, codegenHeader)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `//go:build darwin`)
	fmt.Fprintln(g, `// +build darwin`)
	fmt.Fprintln(g)
	fmt.Fprintf(g, `package %s`+"\n", pkg)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `import (`)
	fmt.Fprintln(g, "\t"+`"sync"`)
	fmt.Fprintln(g)
	fmt.Fprintln(g, "\t"+`"github.com/noncgo/x/darwin/internal/dyld"`)
	fmt.Fprintln(g, `)`)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `// Uh, apparently cgo:cgo_import_dynamic links against function call stub?`)
	fmt.Fprintln(g, `// As a workaround, we use dlsym to get the right address from the loaded image.`)
	fmt.Fprintln(g)
	for _, m := range globals {
		lib := m.From
		fmt.Fprintf(g, `//go:cgo_import_dynamic _ _ "%s"`+"\n", lib)
	}
	fmt.Fprintln(g)
	fmt.Fprintln(g, `var globals struct {`)
	for _, m := range globals {
		for i, global := range m.To {
			if i > 0 {
				fmt.Fprintln(g)
			}
			fmt.Fprintf(g, "\t"+`%s_addr uintptr`+"\n", global)
			fmt.Fprintf(g, "\t"+`%s_once sync.Once`+"\n", global)
		}
	}
	fmt.Fprintln(g, `}`)
	for _, m := range globals {
		for _, global := range m.To {
			fmt.Fprintln(g)
			fmt.Fprintf(g, `func extern_%s_getAddr() uintptr {`+"\n", global)
			fmt.Fprintf(g, "\t"+`globals.%s_once.Do(func() {`+"\n", global)
			fmt.Fprintf(g, "\t\t"+`sym, err := dyld.Lookup("%s")`+"\n", global)
			fmt.Fprintln(g, "\t\t"+`if err != nil {`)
			fmt.Fprintln(g, "\t\t\t"+`panic(err)`)
			fmt.Fprintln(g, "\t\t"+`}`)
			fmt.Fprintf(g, "\t\t"+`globals.%s_addr = sym.Addr`+"\n", global)
			fmt.Fprintln(g, "\t"+`})`)
			fmt.Fprintf(g, "\t"+`return globals.%s_addr`+"\n", global)
			fmt.Fprintln(g, `}`)
		}
	}
	if err := os.WriteFile("zglobals.go", g.Bytes(), 0o644); err != nil {
		log.Fatal(err)
	}
}

func genGoTypes(types []Mapping) {
	g := bytes.NewBuffer(nil)
	fmt.Fprintln(g, codegenHeader)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `//go:build darwin`)
	fmt.Fprintln(g, `// +build darwin`)
	fmt.Fprintln(g)
	fmt.Fprintf(g, `package %s`+"\n", pkg)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `// Pointer is an opaque reference that satisfies all interfaces in this package.`)
	fmt.Fprintln(g, `type Pointer uintptr`)
	fmt.Fprintln(g)
	fmt.Fprintln(g, `// Pointer returns the underlying opaque pointer value.`)
	fmt.Fprintln(g, `func (p Pointer) Pointer() uintptr { return uintptr(p) }`)
	for _, m := range types {
		typ := m.From
		fmt.Fprintln(g)
		fmt.Fprintf(g, `// private%[1]s implements the %[1]s interface.`+"\n", typ)
		fmt.Fprintf(g, `func (p Pointer) private%s() {}`+"\n", typ)
	}
	for _, m := range types {
		typ := m.From
		fmt.Fprintln(g)
		fmt.Fprintf(g, `// %[1]s is an opaque reference to %[1]s type.`+"\n", typ)
		fmt.Fprintf(g, `type %s interface {`+"\n", typ)
		for _, impl := range m.To {
			fmt.Fprintln(g, "\t"+impl)
		}
		if len(m.To) == 0 {
			fmt.Fprintln(g, "\t"+`Pointer() uintptr`)
		}
		fmt.Fprintln(g)
		fmt.Fprintf(g, "\t"+`private%s()`+"\n", typ)
		fmt.Fprintln(g, `}`)
	}
	if err := os.WriteFile("ztypes.go", g.Bytes(), 0o644); err != nil {
		log.Fatal(err)
	}
}

type Mapping struct {
	From string
	To   []string
}

func loadMappings(fileName string) ([]Mapping, error) {
	f, err := os.ReadFile(fileName)
	if err != nil {
		return nil, err
	}

	var mappings []Mapping
	var current *Mapping

	scanner := bufio.NewScanner(bytes.NewReader(f))
	for scanner.Scan() {
		line := scanner.Text()
		if before, _, found := strings.Cut(line, "#"); found {
			line = before
		}
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		switch {
		case strings.HasSuffix(line, ":"):
			line = strings.TrimSuffix(line, ":")
			line = strings.TrimSpace(line)
			mappings = append(mappings, Mapping{
				From: line,
			})
			current = &mappings[len(mappings)-1]
			continue
		case strings.HasPrefix(line, "-"):
			line = strings.TrimPrefix(line, "-")
			line = strings.TrimSpace(line)
			if current == nil {
				return nil, fmt.Errorf("mapping element %q before key", line)
			}
			current.To = append(current.To, line)
			continue
		}
		return nil, fmt.Errorf("unrecognized line %q", line)
	}
	return mappings, nil
}

func mustLoadOrNil(fileName string) []Mapping {
	xs, err := loadMappings(fileName)
	if os.IsNotExist(err) {
		return nil
	}
	if err != nil {
		log.Fatal(err)
	}
	if xs == nil {
		return []Mapping{}
	}
	return xs
}
